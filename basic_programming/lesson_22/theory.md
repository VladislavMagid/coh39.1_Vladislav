# Оценка сложности (скорости работы) алгоритмов

## Предварительные замечания

* Алгоритм - последовательность действий, приводящих к какому-либо результату
* Алгоритм может состоять из циклов, условий, последовательных команд
* Алгоритм - это не программа, программа - это реализация алгоритма на конкретном языке программирования

## Подходы к оценке скорости

* Мы хотим понимать, какой алгоритм лучше, какой хуже
  * Мы хотим, чтобы программа работала быстро
* У нас есть два варианта: 
  * оценивать количество памяти, которое требует алгоритм
  * оценивать количество времени, которое требует алгоритм

## Анализ памяти 

* Но оценивать память уже не так интересно, потому что память по сути сейчас "безгранична"
* Лучше оценивать время, потому что мощность процессоров ограничена

## Анализ времени

* Берем секундомер, запускаем программу, и смотрим, сколько она выполняется
* Мы получим какой-либо результат, например, 20 секунд.
* Но что означают эти 20 секунд?
  * Они означают, что конкретно на этом компьютере, конкретно на этих данных программа работала 20 секунд.
  * Мы имеем очень много факторов, язык программирования, компьютер и набор данных.
* Время конечно иногда замеряют, например, когда отдают программу заказчику.

## Анализ количества операций

* Наиболее оптимальный способ оценки работы алгоритмов
* Возьмем несколько элементарных операций:
  * Арифметические операции
  * Присваивание
  * Сравнение
  * Ввод-вывод
* Посчитаем, сколько тот или иной алгоритм таких операций выполняет
* Если мы просто считаем количество операций, то это количество очень сильно зависит от самого набора данных
* Если массив 9 элементов, то 104, а если 1000? а если 10 000?
* А как сделать правильно? Выразить количество операций формулой от количества данных
* Например (см. код `Main2.java`) - `12N + 7`

## Анализ порядка роста количества операций от количества данных

* Мы имеем формулу для алгоритма `12N + 7`.
* Мы можем заметить, что числа 12 и 7 - фиксированные.
* При этом, алгоритм можно улучшить (т.е. получить меньшее количество операций)
* Мы убрали второй цикл и его содержимое засунули в первый, получили `9N + 7`
* Какой алгоритм лучше? `9N + 7` - лучше, потому что требует меньшего количества операций
* Есть один момент, так ли сильно отличаются `12N + 7` и `9N + 7`?

* Функция в математике - Зависимость одной величины от другой
  * В нашем случае:
    * `количество операций` = `f(количество данных)`
    * f(N) = 12N + 7
    * Если у нас N = 10, f(N) = 127
    * В математике мы записали бы `f(x) = 12x + 7`, где `x` - целое положительное
    * График этой функции отражает, насколько быстро увеличивается количество операций от количества данных
* Если мы нарисуем оба графика, то они будут "расти" примерно одинаково, как линия
* Такие функции, вида `y = kx + m` называются линейными
* Алгоритмы, график которых можно изобразить линией, называются `линейными алгоритмами`
* При анализе алгоритмов мы игнорируем числа в формулах, потому что они не столь значительны
* Нам важен `порядок роста`
* Порядок роста линейных функций (алгоритмов) - линейный - `y = x`
* Мы говорим, что у линейных алгоритмов количество операций растет от количества данных - `линейно`
* Обозначается как `O(N)` - семейство линейных алгоритмов

* А если оценивать сортировку выбором?
  * При оценке сортировки не будем обращать внимания на фиксированные числа, а будем считать только количество сравнений
  
```
При i = 0, сколько сравнений мы сделаем?
  j => 1 до 8 (7 сравнений)
При i = 1, сколько срванений мы сделаем?
  j => 2 до 8 (6 сравнений)
При i = 2, сколько срванений мы сделаем?
  j => 3 до 8 (5 сравнений)
При i = 3, сколько срванений мы сделаем?
  j => 4 до 8 (4 сравнений)
При i = 4, сколько срванений мы сделаем?
  j => 5 до 8 (3 сравнений)
При i = 5, сколько срванений мы сделаем?
  j => 6 до 8 (2 сравнений)
При i = 6, сколько срванений мы сделаем?
  j => 7 до 8 (1 сравнение)
  
Всего для 9 чисел мы делаем:

1 + 2 + 3 + 4 + 5 + 6 + 7 сравнений = 28 сравнений
```

* Для произвольного массива длины N мы сделаем `1 + 2 + 3 + 4 + ... + N - 2` сравнений
* Для простоты уберем `-2`, получим: `1 + 2 + 3 + 4 + ... + N`
* Как это изобразить более понятно для нас?
* `1 + 2 + 3 + 4 + ... + N` - сумма элементов арифметической прогрессии
* Для суммы элементов такой прогрессии есть формула 

```
сумма элементов = ( (1 + N) * N ) / 2
```

* Раскрываем скобки:

```
(N + N*N ) / 2 = 0.5 * N * N + N * 0.5
```

* Итого имеем формулу `0.5 * N * N + N * 0.5` для сортировки выбором
* Попробуем нарисовать ее график, получаем параболу (просто немного другу, чем `y = x^2`)
* Алгоритмы, график сложности которых имеет вид параболы, называются `квадратичными`
* Они растут очень быстро, в отличие от линейных
* Это семейство квадратичных алгоритмов, к ним относятся некоторые сортировки (например, пузырьковая, выбором)
* Квадратичные алгоритмы работают медленнее
* Квадратичные алгоритмы обозначаются как `O(N^2)`

## А какие еще бывают алгоритмы?

* Есть алгоритм бинарного поиска (похоже на поиск слова в словаре), его сложность - `O(logN)`
* Такой алгоритм называют логарифмическим и он растет очень медленно
* Есть алгоритмы быстрых сортировок (сортировка слиянием), у нее сложность `O(N log(N))`

## Итог

* `O(1)` < `O(logN)` < `O(N)` < `O(N log(N))` < `O(N^2)`

* Мы знаем, что есть (в основном) четыре вида сложностей
* Они отличаются друг от друга скоростью работы от количества данных
* Мы знаем, какие принципы используются для расчета этих скоростей (подбираем формулу, упрощаем, делаем запись в виде O-нотации)

## Самостоятельно

* Посмотрите видео про бинарный поиск (на java)
* Почитайте про то, что такое степени и логарифмы
* Повторите конспект